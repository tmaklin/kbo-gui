diff --git a/Cargo.toml b/Cargo.toml
index 8818ee2..c2dff4a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,81 +1,34 @@
-# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
-#
-# When uploading crates to the registry Cargo will automatically
-# "normalize" Cargo.toml files for maximal compatibility
-# with all versions of Cargo and also rewrite `path` dependencies
-# to registry (e.g., crates.io) dependencies.
-#
-# If you are reading this file be aware that the original Cargo.toml
-# will likely look very different (and much more reasonable).
-# See Cargo.toml.orig for the original contents.
-
 [package]
-edition = "2021"
-rust-version = "1.77"
 name = "sbwt"
 version = "0.3.3"
-authors = ["Jarno Niklas Alanko <alanko.jarno@gmail.com>"]
-build = false
-autobins = false
-autoexamples = false
-autotests = false
-autobenches = false
-description = "Indexing sets of DNA k-mers with the spectral Burrow-Wheeler transform."
-readme = "README.md"
+edition = "2021"
+rust-version = "1.77" # 1.77 needed for File::create_new
 license = "MIT"
+description = "Indexing sets of DNA k-mers with the spectral Burrow-Wheeler transform."
 repository = "https://github.com/jnalanko/sbwt-rs-cli/tree/master/api"
+authors = ["Jarno Niklas Alanko <alanko.jarno@gmail.com>"]
 
-[lib]
-name = "sbwt"
-path = "src/lib.rs"
-
-[dependencies.bitvec]
-version = "1.0.1"
-
-[dependencies.byteorder]
-version = "1.5"
-
-[dependencies.chrono]
-version = "0.4"
-
-[dependencies.clap]
-version = "4.4"
-
-[dependencies.crossbeam]
-version = "0.5"
-
-[dependencies.embed-doc-image]
-version = "0.1.4"
-
-[dependencies.env_logger]
-version = "0.10"
-
-[dependencies.jseqio]
-version = "0.1.3"
-
-[dependencies.log]
-version = "0.4"
-
-[dependencies.num]
-version = "0.4"
-
-[dependencies.rand]
-version = "0.7"
-
-[dependencies.rayon]
-version = "1"
-
-[dependencies.read_exact]
-version = "0.0.1"
-
-[dependencies.simple-sds-sbwt]
-version = "0.3.1"
-
-[dependencies.test-log]
-version = "0.2"
-
-[dependencies.unitig_flipper]
-version = "0.1.0"
-
-[dev-dependencies.rand_chacha]
-version = "0.3.1"
+[features]
+default = []
+bpks-mem = []
+
+[dependencies]
+rayon = "1"
+num = "0.4"
+simple-sds-sbwt = "0.3.1"
+clap = "4.4"
+jseqio = "0.1.3"
+unitig_flipper = "0.1.0" 
+env_logger = "0.10"
+log = "0.4"
+crossbeam = "0.5"
+read_exact = "0.0.1"
+bitvec = "1.0.1"
+rand = "0.7"
+test-log = "0.2"
+byteorder = "1.5"
+chrono = "0.4"
+embed-doc-image = "0.1.4"
+
+[dev-dependencies]
+rand_chacha = "0.3.1" # Seeded rng in tests
diff --git a/src/bitpacked_kmer_sorting/cursors.rs b/src/bitpacked_kmer_sorting/cursors.rs
index d01ce41..b4ee4ad 100644
--- a/src/bitpacked_kmer_sorting/cursors.rs
+++ b/src/bitpacked_kmer_sorting/cursors.rs
@@ -3,7 +3,7 @@ use std::{io::{BufReader, Seek, Read}, fs::File, path::Path};
 use simple_sds_sbwt::{ops::Access, raw_vector::AccessRaw};
 use std::io::SeekFrom;
 use std::cmp::min;
-use super::kmer::LongKmer;
+use crate::kmer::LongKmer;
 use crate::util::binary_search_leftmost_that_fulfills_pred;
 
 pub struct DummyNodeMerger<R: std::io::Read, const B: usize> {
diff --git a/src/bitpacked_kmer_sorting/dummies.rs b/src/bitpacked_kmer_sorting/dummies.rs
index 8a1c909..5355046 100644
--- a/src/bitpacked_kmer_sorting/dummies.rs
+++ b/src/bitpacked_kmer_sorting/dummies.rs
@@ -1,18 +1,10 @@
 use std::io::{BufWriter, Write};
 
-use super::kmer::LongKmer;
+use crate::kmer::LongKmer;
 use crate::tempfile::TempFileManager;
 use simple_sds_sbwt::raw_vector::*;
 use rayon::prelude::*;
 
-struct NullReader{}
-
-impl std::io::Read for NullReader{
-    fn read(&mut self, _buf: &mut [u8]) -> std::io::Result<usize>{
-        Ok(0) // EoF
-    }
-}
-
 // We take in a path and not a file object because we need multiple readers to the same file
 pub fn get_sorted_dummies<const B: usize>(sorted_kmers_filepath: &std::path::Path, sigma: usize, k: usize, temp_file_manager: &mut TempFileManager) -> Vec<(LongKmer::<B>, u8)>{
 
diff --git a/src/bitpacked_kmer_sorting/kmer_chunk.rs b/src/bitpacked_kmer_sorting/kmer_chunk.rs
index 3afd13d..ccb3d08 100644
--- a/src/bitpacked_kmer_sorting/kmer_chunk.rs
+++ b/src/bitpacked_kmer_sorting/kmer_chunk.rs
@@ -1,5 +1,5 @@
 use std::cmp::*;
-use super::kmer::LongKmer;
+use crate::kmer::LongKmer;
 
 // B is the number of u64 words in a k-mer
 pub struct KmerChunk<const B: usize>{
diff --git a/src/bitpacked_kmer_sorting/kmer_splitter.rs b/src/bitpacked_kmer_sorting/kmer_splitter.rs
index 79eb686..1a26277 100644
--- a/src/bitpacked_kmer_sorting/kmer_splitter.rs
+++ b/src/bitpacked_kmer_sorting/kmer_splitter.rs
@@ -1,4 +1,4 @@
-use super::kmer::*;
+use crate::kmer::*;
 use super::kmer_chunk::KmerChunk;
 use crate::tempfile::{TempFile, TempFileManager};
 use crate::util::DNA_ALPHABET;
diff --git a/src/bitpacked_kmer_sorting/mod.rs b/src/bitpacked_kmer_sorting/mod.rs
index f4ec05d..da8b66a 100644
--- a/src/bitpacked_kmer_sorting/mod.rs
+++ b/src/bitpacked_kmer_sorting/mod.rs
@@ -3,9 +3,10 @@
 mod dummies;
 mod kmer_splitter;
 mod cursors;
-mod kmer;
 mod kmer_chunk;
 
+use crate::kmer::LongKmer;
+
 use std::io::Seek;
 
 use crate::{sbwt::{PrefixLookupTable, SbwtIndex}, streaming_index::LcsArray, subsetseq::SubsetSeq, tempfile::TempFileManager, util::DNA_ALPHABET};
@@ -29,7 +30,7 @@ pub fn build_with_bitpacked_kmer_sorting<const B: usize, IN: crate::SeqStream +
         kmer_splitter::concat_files(bin_files, &mut kmers_file.file);
         kmers_file.file.seek(std::io::SeekFrom::Start(0)).unwrap();
 
-        let n_kmers = std::fs::metadata(&kmers_file.path).unwrap().len() as usize / kmer::LongKmer::<B>::byte_size();
+        let n_kmers = std::fs::metadata(&kmers_file.path).unwrap().len() as usize / LongKmer::<B>::byte_size();
 
         log::info!("{} distinct k-mers found", n_kmers);
 
diff --git a/src/bitpacked_kmer_sorting_mem/cursors.rs b/src/bitpacked_kmer_sorting_mem/cursors.rs
new file mode 100644
index 0000000..402840b
--- /dev/null
+++ b/src/bitpacked_kmer_sorting_mem/cursors.rs
@@ -0,0 +1,165 @@
+use simple_sds_sbwt::{raw_vector::AccessRaw};
+use std::cmp::min;
+use crate::kmer::LongKmer;
+use crate::util::binary_search_leftmost_that_fulfills_pred;
+
+use rayon::iter::IntoParallelIterator;
+use rayon::iter::ParallelIterator;
+use rayon::prelude::ParallelSlice;
+
+pub fn find_in_dummy<const B: usize>(
+    dummy_file: &std::io::Cursor<Vec<(LongKmer<B>, u8)>>,
+    c: u8,
+) -> u64 {
+    let dummy_file_len = dummy_file.get_ref().len();
+
+    let access_fn = |pos| {
+        let record = dummy_file.get_ref()[pos];
+        record
+    };
+
+    let pred_fn = |kmer: (LongKmer::<B>,u8)| {
+        kmer.1 > 0 && kmer.0.get_from_left(0) >= c
+    };
+
+    let start = binary_search_leftmost_that_fulfills_pred(
+        access_fn,
+        pred_fn,
+        dummy_file_len);
+
+    start as u64
+}
+
+pub fn find_in_nondummy<const B: usize>(
+    nondummy_file: &std::io::Cursor<Vec<LongKmer<B>>>,
+    c: u8,
+) -> u64 {
+    let nondummy_file_len = nondummy_file.get_ref().len() as usize;
+
+    let access_fn = |pos| {
+        nondummy_file.get_ref()[pos as usize]
+    };
+
+    let pred_fn = |kmer: LongKmer::<B>| {
+        kmer.get_from_left(0) >= c
+    };
+
+    let start = binary_search_leftmost_that_fulfills_pred(
+        access_fn,
+        pred_fn,
+        nondummy_file_len);
+
+    start as u64
+}
+
+// Returns the LCS array
+pub fn build_lcs_array<const B: usize>(
+    kmers: &Vec<(LongKmer::<B>, u8)>,
+    k: usize,
+) -> simple_sds_sbwt::int_vector::IntVector {
+    // LCS values are between 0 and k-1
+    assert!(k > 0);
+
+    std::iter::once(0_usize).chain(kmers.par_windows(2).map(|window| {
+        // The longest common suffix is the longest common prefix of reversed k-mers
+        let prev_kmer = &window[0].0;
+        let prev_len = &window[0].1;
+        let kmer = &window[1].0;
+        let len = &window[1].1;
+        let mut lcs_value = LongKmer::<B>::lcp(&prev_kmer, &kmer);
+        lcs_value = min(lcs_value, min(*prev_len as usize, *len as usize));
+        lcs_value
+    }).collect::<Vec<usize>>().into_iter()).collect::<simple_sds_sbwt::int_vector::IntVector>()
+}
+
+// Read the next kmer or dummy from data stored separately in memory
+pub fn read_kmer_or_dummy<const B: usize>(
+    kmers: &mut std::io::Cursor<Vec<LongKmer<B>>>,
+    dummies: &mut std::io::Cursor<Vec<(LongKmer<B>, u8)>>,
+    k: usize,
+) -> (LongKmer<B>, u8) {
+    let n_kmers = kmers.get_ref().len();
+    let n_dummies = dummies.get_ref().len();
+    let kmers_pos = kmers.position() as usize;
+    let dummies_pos = dummies.position() as usize;
+
+    if kmers_pos == n_kmers {
+        dummies.set_position(dummies_pos as u64 + 1);
+        dummies.get_ref()[dummies_pos]
+    } else if dummies_pos == n_dummies {
+        kmers.set_position(kmers_pos as u64 + 1);
+        (kmers.get_ref()[kmers_pos], k as u8)
+    } else {
+        if dummies.get_ref()[dummies_pos] < (kmers.get_ref()[kmers_pos], k as u8) {
+            dummies.set_position(dummies_pos as u64 + 1);
+            dummies.get_ref()[dummies_pos]
+        } else {
+            kmers.set_position(kmers_pos as u64 + 1);
+            (kmers.get_ref()[kmers_pos], k as u8)
+        }
+    }
+}
+
+
+pub fn merge_kmers_and_dummies<const B: usize>(
+    kmers: &mut std::io::Cursor<Vec<LongKmer<B>>>,
+    dummies: &mut std::io::Cursor<Vec<(LongKmer<B>, u8)>>,
+    k: usize,
+) -> std::io::Cursor<Vec<(LongKmer<B>, u8)>> {
+
+    let n_merged = kmers.get_ref().len() + dummies.get_ref().len();
+
+    std::io::Cursor::new(Vec::from((0..n_merged).map(|_| {
+        read_kmer_or_dummy(kmers, dummies, k)
+    }).collect::<Vec<(LongKmer::<B>, u8)>>()))
+}
+
+// Returns the SBWT bit vectors and optionally the LCS array
+pub fn build_sbwt_bit_vectors<const B: usize>(
+    merged: &std::io::Cursor<Vec<(LongKmer<B>, u8)>>,
+    k: usize,
+    sigma: usize,
+    build_lcs: bool,
+) -> (Vec<simple_sds_sbwt::raw_vector::RawVector>, Option<simple_sds_sbwt::int_vector::IntVector>) {
+
+    let n = merged.get_ref().len();
+
+    let rawrows = (0..sigma).collect::<Vec<usize>>().into_par_iter().map(|c|{
+        let mut rawrow = simple_sds_sbwt::raw_vector::RawVector::with_len(n, false);
+        let mut pointed_idx = find_in_dummy(&merged, c as u8) as usize;
+        let end = if c < sigma - 1 { find_in_dummy(&merged, c as u8 + 1) as usize } else { n };
+
+        merged.get_ref().iter().enumerate().for_each(|(kmer_idx, (kmer, len))| {
+            let kmer_c = if *len as usize == k {
+                (
+                    kmer
+                        .set_from_left(k - 1, 0)
+                        .right_shift(1)
+                        .set_from_left(0, c as u8),
+                    k as u8,
+                )
+            } else {
+                (kmer.right_shift(1).set_from_left(0, c as u8), len + 1) // Dummy
+            };
+
+            while pointed_idx < end && merged.get_ref()[pointed_idx] < kmer_c {
+                pointed_idx += 1;
+            }
+
+            if pointed_idx < end && merged.get_ref()[pointed_idx] == kmer_c {
+                rawrow.set_bit(kmer_idx, true);
+                pointed_idx += 1;
+            }
+        });
+        rawrow
+    }).collect::<Vec<simple_sds_sbwt::raw_vector::RawVector>>();
+
+    let lcs = if build_lcs {
+        // LCS values are between 0 and k-1
+        Some(build_lcs_array(merged.get_ref(), k))
+    } else {
+        None
+    };
+
+    (rawrows, lcs)
+}
diff --git a/src/bitpacked_kmer_sorting_mem/dummies.rs b/src/bitpacked_kmer_sorting_mem/dummies.rs
new file mode 100644
index 0000000..1f3a1ea
--- /dev/null
+++ b/src/bitpacked_kmer_sorting_mem/dummies.rs
@@ -0,0 +1,100 @@
+use crate::bitpacked_kmer_sorting_mem::cursors::find_in_nondummy;
+use crate::kmer::LongKmer;
+
+use simple_sds_sbwt::ops::Select;
+use simple_sds_sbwt::ops::SelectZero;
+use simple_sds_sbwt::bit_vector::BitVector;
+use simple_sds_sbwt::raw_vector::*;
+use rayon::prelude::*;
+
+pub fn get_set_bits<const B: usize>(
+    kmers: &Vec<LongKmer::<B>>,
+    cursor: &mut (std::io::Cursor<Vec<LongKmer<B>>>, usize),
+    k: usize,
+    c: u8,
+) -> simple_sds_sbwt::raw_vector::RawVector {
+    let mut bits = simple_sds_sbwt::raw_vector::RawVector::new();
+    bits.resize(kmers.len(), false);
+    // let mut set_bits: Vec<usize> = Vec::new();
+    let mut pointed_idx = 0;
+    kmers.iter().for_each(|x| {
+        let xc = x.set_from_left(k-1, 0).right_shift(1).set_from_left(0, c as u8);
+
+        while pointed_idx < cursor.0.get_ref().len() {
+            match cursor.0.get_ref()[pointed_idx].cmp(&xc) {
+                std::cmp::Ordering::Greater => {
+                    break
+                },
+                std::cmp::Ordering::Equal => {
+                    // set_bits.push(cursor.nondummy_position());
+                    bits.set_bit(pointed_idx + cursor.1, true);
+                    pointed_idx += 1; // Advance
+                    break
+                },
+                std::cmp::Ordering::Less => {
+                    pointed_idx += 1; // Advance
+                    // no break
+                }
+            }
+        }
+    });
+
+    bits
+}
+
+// We take in a path and not a file object because we need multiple readers to the same file
+pub fn get_sorted_dummies<const B: usize>(
+    sorted_kmers: &mut std::io::Cursor::<Vec<LongKmer::<B>>>,
+    sigma: usize, k: usize,
+) -> std::io::Cursor<Vec<(LongKmer<B>, u8)>> {
+    // Number of k-mers in file
+    let n = sorted_kmers.get_ref().len();
+
+    // Iterate in reverse bc moving data from the beginning of sorted_kmers is slow
+    let mut char_cursors = (0..sigma).rev().map(|c|{
+        let pos = find_in_nondummy::<B>(sorted_kmers, c as u8);
+        let start = pos as usize;
+        let end = if c < sigma - 1 {
+            find_in_nondummy::<B>(sorted_kmers, c as u8 + 1)
+        } else {
+            sorted_kmers.get_ref().len() as u64
+        };
+        (std::io::Cursor::<Vec<LongKmer::<B>>>::new(Vec::from(std::mem::take(
+            &mut sorted_kmers.get_ref()
+                    [start..(end as usize)].to_vec()
+        ))),
+        pos as usize)
+    }).rev().collect::<Vec<(std::io::Cursor::<Vec<LongKmer::<B>>>, usize)>>();
+
+    let has_predecessor = char_cursors.par_iter_mut().enumerate().map(|(c, cursor)| {
+        get_set_bits(sorted_kmers.get_ref(), cursor, k, c as u8)
+    }).reduce(|| {
+        let mut res = simple_sds_sbwt::raw_vector::RawVector::new();
+        res.resize(n, false);
+        res
+    }, |mut a, b| {
+        let bv = BitVector::from(b);
+        bv.one_iter().for_each(|idx| a.set_bit(idx.1, true));
+        a
+    });
+
+    let iterable = BitVector::from(has_predecessor);
+    let mut required_dummies: Vec::<(LongKmer::<B>, u8)> = iterable.zero_iter().par_bridge().map(|x| {
+        let mut prefix = sorted_kmers.get_ref()[x.1];
+        (0..k).collect::<Vec<usize>>().iter().map(|i| {
+            let len = k - i - 1;
+            prefix = prefix.left_shift(1);
+            (prefix, len as u8)
+        }).collect::<Vec<(LongKmer::<B>, u8)>>()
+    }).flatten().collect();
+
+    // We always assume that the empty k-mer exists. This assumption is reflected in the C-arrya
+    // later, which adds one "ghost dollar" count to all counts.
+    required_dummies.push((LongKmer::<B>::from_ascii(b"").unwrap(), 0));
+
+    required_dummies.par_sort_unstable();
+    required_dummies.dedup();
+    required_dummies.shrink_to_fit();
+
+    std::io::Cursor::new(Vec::from(required_dummies))
+}
diff --git a/src/bitpacked_kmer_sorting_mem/kmer_splitter.rs b/src/bitpacked_kmer_sorting_mem/kmer_splitter.rs
new file mode 100644
index 0000000..6defb46
--- /dev/null
+++ b/src/bitpacked_kmer_sorting_mem/kmer_splitter.rs
@@ -0,0 +1,71 @@
+use crate::kmer::LongKmer;
+
+use rayon::iter::IntoParallelRefIterator;
+use rayon::iter::IntoParallelRefMutIterator;
+use rayon::iter::ParallelIterator;
+use rayon::prelude::ParallelSlice;
+use rayon::prelude::ParallelSliceMut;
+
+pub fn split_to_bins<const B: usize, IN: crate::SeqStream + Send>(
+    mut seqs: IN,
+    k: usize,
+    dedup_batches: bool,
+) -> Vec<std::io::Cursor::<Vec<LongKmer::<B>>>> {
+
+    // Beware: changing the number of bins, or their order, messes up the
+    // results and may not always break all tests.
+    //
+    // This function makes weird implicit assumptions that are violated if the
+    // operations are performed differently?
+
+    let mut buf = Vec::<Box<[u8]>>::new();
+    while let Some(seq) = seqs.stream_next() {
+        let mut seq_copy = seq.to_owned();
+        seq_copy.reverse(); // Reverse to get colex sorting
+        buf.push(seq_copy.into_boxed_slice());
+    }
+
+    let mut kmers = buf.par_iter().map(|seq| {
+        seq.windows(k).filter_map(|bytes| {
+            LongKmer::<B>::from_ascii(bytes).ok()
+        }).collect::<Vec<LongKmer::<B>>>()
+    }).flatten().collect::<Vec<LongKmer::<B>>>();
+
+    kmers.par_sort_unstable_by_key(|kmer| {
+        kmer.get_from_left(0) as usize * 16 + kmer.get_from_left(1) as usize * 4 + kmer.get_from_left(2) as usize
+    });
+
+    kmers.par_chunk_by(|&a, &b| {
+        let x = a.get_from_left(0) as usize * 16 + a.get_from_left(1) as usize * 4 + a.get_from_left(2) as usize;
+        let y = b.get_from_left(0) as usize * 16 + b.get_from_left(1) as usize * 4 + b.get_from_left(2) as usize;
+        x == y}).map(|chunk| {
+        if dedup_batches {
+            let mut dd_chunk = chunk.to_vec();
+            dd_chunk.sort_unstable();
+            dd_chunk.dedup();
+            std::io::Cursor::<Vec<LongKmer::<B>>>::new(dd_chunk)
+        } else {
+            std::io::Cursor::<Vec<LongKmer::<B>>>::new(chunk.to_vec())
+        }
+    }).collect::<Vec<std::io::Cursor::<Vec<LongKmer::<B>>>>>()
+}
+
+// Overwrite the bins with sorted and deduplicates files. Returns back the files after overwriting.
+pub fn par_sort_and_dedup_bin_files<const B: usize>(
+    bins: &mut Vec<std::io::Cursor::<Vec<LongKmer::<B>>>>,
+) {
+   bins.par_iter_mut().for_each(|f| {
+        f.get_mut().sort_unstable();
+        f.get_mut().dedup();
+        f.set_position(0);
+    });
+}
+
+// The original data are deleted
+pub fn concat_files<const B: usize>(
+    binned_kmers: &mut Vec<std::io::Cursor::<Vec<LongKmer::<B>>>>
+) -> std::io::Cursor::<Vec<LongKmer::<B>>> {
+    let mut concat_kmers: Vec<LongKmer::<B>> = Vec::new();
+    binned_kmers.iter_mut().for_each(|file| concat_kmers.append(file.get_mut()));
+    std::io::Cursor::<Vec<LongKmer::<B>>>::new(Vec::from(concat_kmers))
+}
diff --git a/src/bitpacked_kmer_sorting_mem/mod.rs b/src/bitpacked_kmer_sorting_mem/mod.rs
new file mode 100644
index 0000000..66277c8
--- /dev/null
+++ b/src/bitpacked_kmer_sorting_mem/mod.rs
@@ -0,0 +1,63 @@
+//! Build an [SbwtIndex] fully in memory using an algorithm based on bitpacked k-mer sorting.
+
+mod dummies;
+mod kmer_splitter;
+mod cursors;
+
+use crate::{sbwt::{PrefixLookupTable, SbwtIndex}, streaming_index::LcsArray, subsetseq::SubsetSeq, util::DNA_ALPHABET};
+/// Build SBWT and optionally the LCS array fully in memory using bitpacked k-mer sorting.
+///
+/// See [SbwtIndexBuilder](crate::builder::SbwtIndexBuilder) for a wrapper with a more
+/// user-friendly interface. B is the number u64 words in a k-mer.
+///
+/// Unused arguments for signature compatibility with the disk based building algorithm.
+pub fn build_with_bitpacked_kmer_sorting<const B: usize, IN: crate::SeqStream + Send, SS: SubsetSeq + Send>(
+    seqs: IN,
+    k: usize,
+    dedup_batches: bool,
+    build_lcs: bool,
+) -> (SbwtIndex::<SS>, Option<LcsArray>) {
+
+    let sigma = DNA_ALPHABET.len();
+
+    log::info!("Splitting k-mers into bins");
+    let mut kmer_bins = kmer_splitter::split_to_bins::<B, IN>(seqs, k, dedup_batches);
+
+    log::info!("Sorting and deduplicating bins");
+    kmer_splitter::par_sort_and_dedup_bin_files::<B>(&mut kmer_bins);
+
+    let (merged, n_kmers) = {
+        let mut kmers = kmer_splitter::concat_files(&mut kmer_bins);
+        let n_kmers = kmers.get_ref().len();
+
+        log::info!("{} distinct k-mers found", n_kmers);
+        let mut dummies = dummies::get_sorted_dummies::<B>(&mut kmers, sigma, k);
+
+        (cursors::merge_kmers_and_dummies(&mut kmers, &mut dummies, k), n_kmers)
+    };
+
+    log::info!("Constructing the sbwt subset sequence");
+
+    let (rawrows, lcs) = cursors::build_sbwt_bit_vectors::<B>(&merged, k, sigma, build_lcs);
+
+    // Create the C array
+    #[allow(non_snake_case)] // C-array is an established convention in BWT indexes
+    let C: Vec<usize> = crate::util::get_C_array(&rawrows);
+
+    log::info!("Building the subset rank structure");
+    let mut subsetseq = SS::new_from_bit_vectors(rawrows.into_iter().map(simple_sds_sbwt::bit_vector::BitVector::from).collect());
+    subsetseq.build_rank();
+    let n_sets = subsetseq.len();
+    let (mut index, lcs) = (SbwtIndex::<SS>::from_components(
+        subsetseq,
+        n_kmers,
+        k,
+        C,
+        PrefixLookupTable::new_empty(n_sets))
+                            , lcs.map(LcsArray::new));
+
+    let lut = PrefixLookupTable::new(&index, 8);
+    index.set_lookup_table(lut);
+    (index, lcs)
+
+}
diff --git a/src/builder.rs b/src/builder.rs
index 1384d42..12751be 100644
--- a/src/builder.rs
+++ b/src/builder.rs
@@ -45,7 +45,7 @@ pub trait SbwtConstructionAlgorithm {
     fn run<SS: SeqStream + Send>(self, input: SS, k: usize, n_threads: usize, build_lcs: bool) -> (SbwtIndex<SubsetMatrix>, Option<LcsArray>);
 }
 
-/// A construction algorithm based on sorting of bit-packed k-mers.
+/// A construction algorithm based on sorting of bit-packed k-mers using temporary disk space.
 #[derive(Default)]
 #[derive(Clone, Eq, PartialEq, Debug)]
 pub struct BitPackedKmerSorting{
@@ -112,6 +112,61 @@ impl SbwtConstructionAlgorithm for BitPackedKmerSorting {
     }
 }
 
+/// A construction algorithm based on sorting of bit-packed k-mers in memory.
+#[derive(Default)]
+#[derive(Clone, Eq, PartialEq, Debug)]
+#[cfg(feature = "bpks-mem")]
+pub struct BitPackedKmerSortingMem{
+    dedup_batches: bool,
+}
+
+#[cfg(feature = "bpks-mem")]
+impl BitPackedKmerSortingMem {
+
+    /// Initializes the algorithm with default settings:
+    /// - do not deduplicate k-mer batches before sorting.
+    /// - build entirely in memory
+    /// - use rayon threads for parallelism
+    pub fn new() -> Self {
+        Self{dedup_batches: false}
+    }
+
+    /// Whether to deduplicate k-mer batches before sorting. If the input has many duplicate k-mers, this will reduce the disk space required by the algorithm.
+    pub fn dedup_batches(mut self, enable: bool) -> Self {
+        self.dedup_batches = enable;
+        self
+    }
+}
+
+#[cfg(feature = "bpks-mem")]
+impl SbwtConstructionAlgorithm for BitPackedKmerSortingMem {
+    fn run<SS: SeqStream + Send>(self, input: SS, k: usize, _n_threads: usize, build_lcs: bool) -> (SbwtIndex<SubsetMatrix>, Option<LcsArray>) {
+        // Parallelisation is handled with rayon iterators,
+        // thread pool should be initialised before calling.
+        let dedup_batches = self.dedup_batches;
+        match k {
+            0..=32 => {
+                crate::bitpacked_kmer_sorting_mem::build_with_bitpacked_kmer_sorting::<1,_,SubsetMatrix>(input, k, dedup_batches, build_lcs)
+            }
+            33..=64 => {
+                crate::bitpacked_kmer_sorting_mem::build_with_bitpacked_kmer_sorting::<2,_,SubsetMatrix>(input, k, dedup_batches, build_lcs)
+            }
+            65..=96 => {
+                crate::bitpacked_kmer_sorting_mem::build_with_bitpacked_kmer_sorting::<3,_,SubsetMatrix>(input, k, dedup_batches, build_lcs)
+            }
+            97..=128 => {
+                crate::bitpacked_kmer_sorting_mem::build_with_bitpacked_kmer_sorting::<4,_,SubsetMatrix>(input, k, dedup_batches, build_lcs)
+            }
+            129..=256 => {
+                crate::bitpacked_kmer_sorting_mem::build_with_bitpacked_kmer_sorting::<8,_,SubsetMatrix>(input, k, dedup_batches, build_lcs)
+            }
+            _ => {
+                panic!("k > 256 not supported with bitpacked sorting algorithm.");
+            }
+        }
+    }
+}
+
 /// A builder for constructing an SBWT index.
 #[derive(Default)]
 #[derive(Clone, Eq, PartialEq, Debug)]
diff --git a/src/dbg.rs b/src/dbg.rs
index 6e6fab8..9087ef6 100644
--- a/src/dbg.rs
+++ b/src/dbg.rs
@@ -361,6 +361,10 @@ mod tests {
     use std::io::BufRead;
 
     use crate::{builder::{BitPackedKmerSorting, SbwtIndexBuilder}, util};
+
+    #[cfg(feature = "bpks-mem")]
+    use crate::builder::BitPackedKmerSortingMem;
+
     use bitvec::prelude::*;
     use rand_chacha::rand_core::RngCore;
     use super::*;
@@ -693,5 +697,344 @@ mod tests {
         }
 
     }
-}
 
+    ///////////////////////////////////////////////////
+    //
+    // Same tests for bitpacked k-mer sorting in memory
+    //
+    ///////////////////////////////////////////////////
+
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn finimizer_paper_example_unitig_export_mem(){
+        // Note: this test does not cover the cyclic unitig case
+        let seqs: Vec<&[u8]> = vec![b"GTAAGTCT", b"AGGAAA", b"ACAGG", b"GTAGG", b"AGGTA"];
+        let mut seqs_copy: Vec<Vec<u8>> = seqs.iter().map(|x| x.to_vec()).collect(); // For verification in the end
+
+        let (mut sbwt, lcs) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).build_lcs(true).run_from_slices(seqs.as_slice());
+        sbwt.build_select();
+        let dbg = Dbg::new(&sbwt, lcs.as_ref());
+
+        let mut output = Vec::<u8>::new();
+        let out_cursor = std::io::Cursor::new(&mut output);
+        dbg.parallel_export_unitigs(out_cursor);
+
+        let mut unitigs: Vec<Vec<u8>> = vec![];
+        for line in output.lines(){
+            let line = line.unwrap();
+            if !line.starts_with('>'){
+                unitigs.push(line.as_bytes().to_vec());
+            }
+        }
+        unitigs.sort();
+        seqs_copy.sort();
+
+        assert_eq!(unitigs, seqs_copy);
+
+    }
+
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn finimizer_paper_example_dbg_operations_mem(){
+        let seqs: Vec<&[u8]> = vec![b"GTAAGTCT", b"AGGAAA", b"ACAGG", b"GTAGG", b"AGGTA"];
+        let (mut sbwt, lcs) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).build_lcs(true).run_from_slices(seqs.as_slice());
+        sbwt.build_select();
+
+        let lcs = lcs.unwrap();
+        let dbg = Dbg::new(&sbwt, Some(&lcs));
+        let dbg_without_lcs = Dbg::new(&sbwt, None);
+
+        let true_dummy_marks = bitvec![1,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0];
+        assert_eq!(dbg.dummy_marks, true_dummy_marks);
+        assert_eq!(dbg_without_lcs.dummy_marks, true_dummy_marks);
+
+        let true_k_minus_1_marks = bitvec![1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1];
+        assert_eq!(dbg.k_minus_1_marks, true_k_minus_1_marks);
+        assert_eq!(dbg_without_lcs.k_minus_1_marks, true_k_minus_1_marks);
+
+        // Get node
+
+        assert!(dbg.get_node(b"TTAT").is_none());
+        let v = dbg.get_node(b"ACAG").unwrap();
+        assert_eq!(v.id, 11);
+        assert_eq!(dbg.outdegree(v), 1);
+
+        // Push node kmer
+
+        let mut buf = Vec::<u8>::new();
+        dbg.push_node_kmer(v, &mut buf);
+        assert_eq!(&buf, b"ACAG");
+
+        // Has outlabel
+
+        assert!(!dbg.has_outlabel(v , b'A'));
+        assert!(!dbg.has_outlabel(v , b'C'));
+        assert!(dbg.has_outlabel(v , b'G'));
+        assert!(!dbg.has_outlabel(v , b'T'));
+
+        // Follow outedge
+
+        assert!(dbg.follow_outedge(v, b'A').is_none());
+        let v = dbg.follow_outedge(v, b'G').unwrap();
+
+        // Outdegree
+
+        assert_eq!(dbg.outdegree(v), 2);
+
+        // Out labels
+
+        let mut outlabels = Vec::<u8>::new();
+        dbg.push_outlabels(v, &mut outlabels);
+        assert_eq!(outlabels, vec![b'A', b'T']);
+
+        let v = dbg.get_node(b"TAGG").unwrap();
+        let mut outlabels = Vec::<u8>::new();
+        dbg.push_outlabels(v, &mut outlabels);
+        assert_eq!(outlabels, vec![b'A', b'T']);
+
+        // Out neighbors
+
+        let v = dbg.get_node(b"CAGG").unwrap();
+        let mut out_neighbors = Vec::<(Node, u8)>::new();
+        dbg.push_out_neighbors(v, &mut out_neighbors);
+        assert_eq!(out_neighbors, vec![(dbg.get_node(b"AGGA").unwrap(), b'A'), (dbg.get_node(b"AGGT").unwrap(), b'T')]);
+
+        let mut out_neighbors = Vec::<(Node, u8)>::new();
+        dbg.push_out_neighbors(dbg.get_node(b"GTCT").unwrap(), &mut out_neighbors);
+        assert!(out_neighbors.is_empty());
+
+        // Get inlabel
+
+        assert_eq!(dbg.get_last_character(v), b'G');
+        assert_eq!(dbg.get_last_character(Node{id:11}), b'G'); // ACAG
+
+        // Indegree
+
+        let v = dbg.get_node(b"AGGA").unwrap();
+        assert_eq!(dbg.indegree(v), 2);
+
+        let v = dbg.get_node(b"AGGT").unwrap();
+        assert_eq!(dbg.indegree(v), 2);
+
+        let v = dbg.get_node(b"TAGG").unwrap();
+        assert_eq!(dbg.indegree(v), 1);
+
+        assert_eq!(dbg.indegree(Node{id: 11}), 0); // ACAG
+
+        // In neighbors
+
+        let v = dbg.get_node(b"AGGA").unwrap();
+        let mut in_neighbors = Vec::<(Node, u8)>::new();
+        dbg.push_in_neighbors(v, &mut in_neighbors);
+        assert_eq!(in_neighbors, vec![(dbg.get_node(b"CAGG").unwrap(), b'A'), (dbg.get_node(b"TAGG").unwrap(), b'A')]);
+
+        let v = dbg.get_node(b"AGGT").unwrap();
+        let mut in_neighbors = Vec::<(Node, u8)>::new();
+        dbg.push_in_neighbors(v, &mut in_neighbors);
+        assert_eq!(in_neighbors, vec![(dbg.get_node(b"CAGG").unwrap(), b'T'), (dbg.get_node(b"TAGG").unwrap(), b'T')]);
+
+        let mut in_neighbors = Vec::<(Node, u8)>::new();
+        dbg.push_in_neighbors(Node{id: 11}, &mut in_neighbors); // ACAG
+        assert!(in_neighbors.is_empty());
+
+    }
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn cyclic_unitigs_in_export_mem(){
+        use rand_chacha::ChaCha20Rng;
+        use rand_chacha::rand_core::SeedableRng;
+
+        let k = 10_usize;
+        let mut rng = ChaCha20Rng::from_seed([123; 32]);
+        let mut seqs = Vec::<Vec<u8>>::new();
+        for _ in 0..10 {
+            let seq: Vec<u8> = (0..3*k).map(|_| match rng.next_u32() % 4 {
+                0 => b'A',
+                1 => b'C',
+                2 => b'G',
+                _ => b'T',
+            }).collect();
+            seqs.push(seq.clone());
+        }
+
+        let x0 = seqs[0][0..k].to_vec();
+        seqs[0].extend(x0); // Make cyclic
+
+        let x1 = seqs[1][0..k].to_vec();
+        seqs[1].extend(x1); // Make cyclic
+
+        let x2 = seqs[2][0..k].to_vec();
+        seqs[2].extend(x2); // Make cyclic
+
+        let (sbwt, lcs) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(k).build_lcs(true).build_select_support(true).run_from_vecs(seqs.as_slice());
+        let dbg = Dbg::new(&sbwt, lcs.as_ref());
+
+        let mut unitig_ascii_out = Vec::<u8>::new();
+        dbg.parallel_export_unitigs(std::io::Cursor::new(&mut unitig_ascii_out));
+        let unitigs: Vec<Vec<u8>> = unitig_ascii_out.lines().map(|s| s.unwrap().as_bytes().to_owned()).filter(|s| s[0] != b'>').collect();
+
+        let mut n_kmers = 0_usize;
+        for unitig in unitigs.iter(){
+            let self_overlap: bool = unitig[0..k-1] == unitig[unitig.len()-k+1..];
+            eprintln!("{}", String::from_utf8_lossy(unitig));
+            eprintln!("self_overlap: {}", self_overlap);
+            for (i, kmer) in unitig.windows(k).enumerate() {
+                assert!(dbg.get_node(kmer).is_some());
+                let node = dbg.get_node(kmer).unwrap();
+                let indeg = dbg.indegree(node);
+                let outdeg = dbg.outdegree(node);
+
+                if i == 0 { // Check that the unitig is maximal to the left
+                    if self_overlap {
+                        assert_eq!(indeg, 1);
+                    } else if indeg == 1 { // Indeg 0 or >= 2 are always ok.
+                        let pred = dbg.follow_inedge(node, 0).unwrap();
+                        assert!(dbg.outdegree(pred) >= 2);
+                    }
+                }
+                if i + k == unitig.len() { // Check that the unitig is maximal to the right
+                    if self_overlap {
+                        assert_eq!(outdeg, 1);
+                    } else if outdeg == 1 { // Outdeg 0 or >= 2 are always ok.
+                        let mut outlabels = Vec::<u8>::new();
+                        dbg.push_outlabels(node, &mut outlabels);
+                        let succ = dbg.follow_outedge(node, *outlabels.first().unwrap()).unwrap();
+                        assert!(dbg.indegree(succ) >= 2);
+                    }
+                }
+                if i > 0 {
+                    assert_eq!(indeg, 1);
+                }
+                if i + k != unitig.len() {
+                    assert_eq!(outdeg, 1);
+                }
+                n_kmers += 1;
+            }
+        }
+        assert_eq!(n_kmers, sbwt.n_kmers());
+    }
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn randomized_test_mem(){
+        use rand_chacha::ChaCha20Rng;
+        use rand_chacha::rand_core::SeedableRng;
+
+        // Generate 1000 random k-mers using a seeded rng.
+        let k = 5_usize;
+        let mut rng = ChaCha20Rng::from_seed([123; 32]);
+
+        let mut seqs = Vec::<Vec<u8>>::new();
+        let mut seqs_hashset = std::collections::HashSet::<Vec<u8>>::new();
+        for _ in 0..1000 {
+            let kmer: Vec<u8> = (0..k).map(|_| match rng.next_u32() % 4 {
+                0 => b'A',
+                1 => b'C',
+                2 => b'G',
+                _ => b'T',
+            }).collect();
+            seqs.push(kmer.clone());
+            seqs_hashset.insert(kmer);
+        }
+
+        seqs.sort();
+        seqs.dedup();
+
+        let (sbwt, lcs) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(k).build_lcs(true).build_select_support(true).run_from_vecs(seqs.as_slice());
+        let dbg = Dbg::new(&sbwt, lcs.as_ref());
+
+
+        { // Check that node iterator iterates all k-mers (tests node_iterator, get_kmer)
+            let mut extracted_kmers: Vec<Vec<u8>> = dbg.node_iterator().map(|v| dbg.get_kmer(v)).collect();
+            extracted_kmers.sort();
+            eprintln!("{} {}", extracted_kmers.len(), seqs.len());
+            assert_eq!(extracted_kmers, seqs);
+        }
+
+        { // Test get_node
+            for kmer in seqs.iter() {
+                assert_eq!(dbg.get_kmer(dbg.get_node(kmer).unwrap()), *kmer);
+            }
+            // Try to get a non-existent k-mer.
+            assert!(dbg.get_node(b"XXXXX").is_none());
+        }
+
+        { // Test outdegree, has_outlabel, push_outlabels, follow_outedge, push_out_neighbors
+            for v in dbg.node_iterator(){
+                let kmer = dbg.get_kmer(v);
+                eprintln!("Processing {} {}", v.id, String::from_utf8_lossy(&kmer));
+                let mut true_outdegree = 0_usize;
+                let mut true_outlabels = Vec::<u8>::new();
+                let mut true_out_kmers = Vec::<Vec::<u8>>::new();
+                for &c in util::DNA_ALPHABET.iter() {
+                    let mut next = kmer[1..].to_vec();
+                    next.push(c);
+                    let has_c = seqs_hashset.contains(&next);
+                    true_outdegree += has_c as usize;
+                    assert_eq!(has_c, dbg.has_outlabel(v, c));
+                    if has_c {
+                        true_outlabels.push(c);
+                        true_out_kmers.push(next.clone());
+                        let next_node = dbg.follow_outedge(v, c).unwrap();
+                        eprintln!("From {} to {}", v.id, next_node.id);
+                        assert_eq!(dbg.get_kmer(next_node), next);
+                    } else {
+                        assert!(dbg.follow_outedge(v, c).is_none());
+                    }
+                }
+
+                let mut outlabels = Vec::<u8>::new();
+                dbg.push_outlabels(v, &mut outlabels);
+
+                let mut outneighbors = Vec::<(Node, u8)>::new();
+                dbg.push_out_neighbors(v, &mut outneighbors);
+
+                assert_eq!(true_outdegree, dbg.outdegree(v));
+                assert_eq!(outlabels, true_outlabels);
+
+                assert_eq!(outneighbors.len(), true_outdegree);
+                for i in 0..true_outdegree {
+                    assert_eq!(dbg.get_kmer(outneighbors[i].0), true_out_kmers[i]);
+                    assert_eq!(outneighbors[i].1, outlabels[i]);
+                }
+
+            }
+        }
+
+        { // Test indegree, get_last_character, follow_inedge, push_in_neighbors
+            for v in dbg.node_iterator(){
+                let kmer = dbg.get_kmer(v);
+                eprintln!("Processing {} {}", v.id, String::from_utf8_lossy(&kmer));
+                let mut true_indegree = 0_usize;
+                let mut true_in_kmers = Vec::<Vec::<u8>>::new();
+                let true_last_character = *kmer.last().unwrap();
+                assert_eq!(true_last_character, dbg.get_last_character(v));
+                for &c in util::DNA_ALPHABET.iter() {
+                    let mut prev = vec![c];
+                    prev.extend(&kmer[..k-1]);
+                    let has_c = seqs_hashset.contains(&prev);
+                    if has_c {
+                        let prev_node = dbg.follow_inedge(v, true_indegree).unwrap();
+                        assert_eq!(dbg.get_kmer(prev_node), prev);
+                        true_in_kmers.push(prev);
+                        true_indegree += 1;
+                    }
+                }
+                assert!(dbg.follow_inedge(v, true_indegree).is_none()); // As specced in follow_inedge documentation comment
+                assert_eq!(true_indegree, dbg.indegree(v));
+
+                let mut in_neighbors = Vec::<(Node, u8)>::new();
+                dbg.push_in_neighbors(v, &mut in_neighbors);
+
+                for i in 0..true_indegree {
+                    assert_eq!(dbg.get_kmer(in_neighbors[i].0), true_in_kmers[i]);
+                    assert_eq!(in_neighbors[i].1, true_last_character);
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/kmer.rs b/src/kmer.rs
new file mode 100644
index 0000000..3f0c89f
--- /dev/null
+++ b/src/kmer.rs
@@ -0,0 +1,287 @@
+use read_exact::{self, ReadExactExt};
+
+#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash, Debug)]
+pub struct Kmer{
+    data: u64
+}
+
+#[derive(Debug)]
+#[allow(dead_code)]
+pub enum KmerEncodingError{
+    InvalidNucleotide(char), // contains the offending char
+    TooLong(usize), // Contains the length of the k-mer which was too long
+}
+
+// B is the number of u64 in a kmer
+// The k-mer will be a (32*B)-mer
+// NOTE: k-mer comparison only works correctly for equal-length kmers
+// because k-mers are padded with A's at the end to fill B*32 characters
+#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Hash, Debug)]
+pub struct LongKmer<const B: usize>{
+    data: [u64; B] // Packed with 2 bits / nucleotide so that bitwise lex comparison is k-mer lex comparison
+}
+
+// TODO: always pass these by value since this type is Copy?
+#[allow(dead_code)]
+impl<const B: usize> LongKmer<B>{
+
+    // If the length of the ASCII string is less than 32*B, the k-mer is padded with A's from the left
+    pub fn from_ascii(ascii: &[u8]) -> Result<Self, KmerEncodingError>{
+        if ascii.len() > B*32{
+            return Err(KmerEncodingError::TooLong(ascii.len()));
+        }
+        let mut data = [0_u64; B];
+        for (i, c) in ascii.iter().enumerate() {
+            let bitpair: u64 = match *c{
+                b'A' => 0,
+                b'C' => 1,
+                b'G' => 2,
+                b'T' => 3,
+                _ => {return Err(KmerEncodingError::InvalidNucleotide(*c as char))}
+            };
+            let block = i / 32;
+            let off = 31 - i % 32;
+            //eprintln!("Set {} {} {} {}", c, block, off, bitpair);
+            data[block] |= bitpair << (2*off);
+        }
+        
+        Ok(Self{data})
+    }
+
+    pub fn set_from_left(&self, i: usize, c: u8) -> Self {
+        let pos = i;
+        let block = pos / 32;
+        let off = 31 - pos % 32;
+        let mask = 3_u64 << (2*off);
+
+
+        let mut data_copy = self.data;
+        data_copy[block] = (data_copy[block] & !mask) | ((c as u64) << (2*off));
+
+        Self{data: data_copy}
+    }
+
+    pub fn get_from_left(&self, i: usize) -> u8 {
+        let pos = i;
+        let block = pos / 32;
+        let off = 31 - pos % 32;
+        //eprintln!("Get {} {} {}", block, off, pos);
+        ((self.data[block] >> (2*off)) & 3) as u8
+    }
+
+    // Extends with A's at the end
+    pub fn right_shift(&self, chars: usize) -> Self{
+        // TODO: this could be done without any branching
+        let mut new_data = [0_u64; B];
+        for block in 0..B{
+            let b1 = block + chars / 32; // Which block the first char lands on
+            let o1 = (chars % 32) * 2; // Which bit within block the first char lands on
+            let b2 = block + (31 + chars) / 32; // Which block the last char lands on
+            if b1 < B {
+                new_data[b1] |= self.data[block] >> o1;
+            }
+            if b2 < B {
+                let shift = 64 - o1; 
+
+                // shift by 64 is panic
+                if shift < 64 {
+                    new_data[b2] |= self.data[block] << shift;
+                }
+            }
+        }
+        Self{data: new_data}
+    }
+
+
+
+    pub fn left_shift(&self, chars: usize) -> Self{
+        // TODO: this could be done without any branching
+        let chars = chars as isize;
+        let mut new_data = [0_u64; B];
+        for block in 0..(B as isize){
+            let b1 = block - (chars + 31) / 32; // Which block the first char lands on
+            let o1 = ((32 - (chars % 32)) * 2) % 64; // Which bit within block the first char lands on
+            let b2 = block - chars / 32; // Which block the last char lands on
+            if b1 >= 0 {
+                new_data[b1 as usize] |= self.data[block as usize] >> o1;
+            }
+            if b2 >= 0 {
+                let shift = 64 - o1; 
+
+                // shift by 64 is panic
+                if shift < 64 {
+                    new_data[b2 as usize] |= self.data[block as usize] << shift;
+                }
+            }
+        }
+        Self{data: new_data}
+    }
+
+
+    #[allow(dead_code)]
+    pub fn get_u64_data(&self) -> &[u64]{
+        &self.data
+    }
+
+    pub fn from_u64_data(data: [u64; B]) -> Self{
+        Self{data}
+    }
+
+    pub fn byte_size() -> usize {
+        8*B
+    }
+
+    pub fn serialize<W: std::io::Write>(&self, out: &mut W) -> std::io::Result<usize>{
+        // TODO: maybe use an unsafe single write to avoid the loop
+        let mut written = 0;
+        for block in self.data.iter(){
+            let bytes = block.to_le_bytes();
+            out.write_all(&bytes)?;
+            written += bytes.len();
+        }
+        Ok(written)
+    }
+
+    // Returns Ok(None) if the stream gives an EOF
+    pub fn load<R: std::io::Read>(input: &mut R) -> std::io::Result<Option<Self>>{
+        // TODO: read with just 1 IO call
+        // TODO: this should return an error if could not read 8*B bytes
+        // These todos may seem easy but they are not because the const generic support is not good enough yet
+        let mut data = [0_u64; B];
+        let mut buf = [0_u8; 8];
+        for block in data.iter_mut(){
+            match input.read_exact_or_eof(&mut buf) {
+                Ok(true) => {*block = u64::from_le_bytes(buf);},
+                Ok(false) => return Ok(None), // EOF
+                Err(e) => return Err(e),
+            }
+        }
+        Ok(Some(Self::from_u64_data(data)))
+    }
+
+    pub fn lcp(a: &Self, b: &Self) -> usize{
+        for i in 0..B{
+            let xor = a.data[i] ^ b.data[i];
+            if xor != 0{
+                return 32*i + xor.leading_zeros() as usize / 2;
+            }
+        }
+        B*32 // Full k-mer match: 32 nucleotids per block
+    }
+
+}
+
+impl<const B: usize> std::fmt::Display for LongKmer<B>{
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        let mut s = String::new();
+        for i in 0..B*32{
+            s.push(match self.get_from_left(i){
+                0 => 'A',
+                1 => 'C',
+                2 => 'G',
+                3 => 'T',
+                _ => panic!("Invalid character in DNA sequence"),
+            });
+        }
+        write!(f, "{}", s)
+    }
+}
+
+#[cfg(test)]
+mod tests{
+    use super::*;
+
+    #[allow(clippy::ptr_arg)]
+    fn left_shifted(s: &String) -> String {
+        let mut s = s.clone();
+        s.remove(0);
+        s.push('A');
+        s
+    }
+
+    #[allow(clippy::ptr_arg)]
+    fn right_shifted(s: &String) -> String {
+        let mut s = s.clone();
+        s.pop();
+        s.insert(0, 'A');
+        s
+    }
+
+    #[test]
+    fn test_lcp(){
+        let ascii1 = b"ACGTACGTACGTACGTACGTACGTACGTACGTACATGCATTT";
+        let ascii2 = b"ACGTACGTACGTACGTACGTACGTACGTACGTACATGCATAT";
+        let x = LongKmer::<2>::from_ascii(ascii1).unwrap();        
+        let y = LongKmer::<2>::from_ascii(ascii2).unwrap();        
+        assert_eq!(LongKmer::<2>::lcp(&x, &y), 40);
+
+        // Equal k-mers
+        let ascii1 = b"ACGTACGTACGTACGTACGTACGTACGTACGTACATGCATTTCTAGCTAGCTGATCGATCGA";
+        let ascii2 = b"ACGTACGTACGTACGTACGTACGTACGTACGTACATGCATTTCTAGCTAGCTGATCGATCGA";
+        let x = LongKmer::<2>::from_ascii(ascii1).unwrap();        
+        let y = LongKmer::<2>::from_ascii(ascii2).unwrap();        
+        assert_eq!(LongKmer::<2>::lcp(&x, &y), 64);
+    }
+
+    #[test]
+    #[allow(clippy::nonminimal_bool)]
+    fn test_long_kmer(){
+        let ascii = b"ACGTACGTACGTACGTACGTACGTACGTACGTACATGCATTT";
+        let mut x = LongKmer::<2>::from_ascii(ascii).unwrap();        
+
+        // Setting and getting
+
+        x = x.set_from_left(0, 2);
+        x = x.set_from_left(1, 3);
+        x = x.set_from_left(62, 1);
+        eprintln!("{}", x);
+
+        let mut expected = String::from("GTGTACGTACGTACGTACGTACGTACGTACGTACATGCATTTAAAAAAAAAAAAAAAAAAAACA");
+        let actual = format!("{}", x); // This currently uses get_from_left
+        assert_eq!(expected, actual);
+
+        // Shifts
+
+        for i in 0..100{
+            let our = x.left_shift(i);
+            eprintln!("{}", our);
+            assert_eq!(expected, format!("{}", our));
+            expected = left_shifted(&expected);
+        }
+
+        expected = String::from("GTGTACGTACGTACGTACGTACGTACGTACGTACATGCATTTAAAAAAAAAAAAAAAAAAAACA");
+        for i in 0..100{
+            let our = x.right_shift(i);
+            eprintln!("{}", our);
+            assert_eq!(expected, format!("{}", our));
+            expected = right_shifted(&expected);
+        }
+
+        // Comparison
+        let x = LongKmer::<2>::from_ascii(b"AATCAGCTAGCTACTATCTACGTACTACGTACGGGCGTACGTAGCA").unwrap();
+        let y = LongKmer::<2>::from_ascii(b"AATCAGCTAGCTACTATCTACGTACTACGTACGGGCGTACGTCAGC").unwrap();
+
+        assert!(x < y);
+
+        let x = LongKmer::<2>::from_ascii(b"GGGGAC").unwrap();
+        let y = LongKmer::<2>::from_ascii(b"GGGGAC").unwrap();
+
+        assert!(x == y);
+        assert!(x <= y);
+        assert!(!(x < y));
+        assert!(!(x > y));
+
+        // COMPARISON ONLY WORKS FOR EQUAL-LENGTH kmers
+        /* 
+        let x = LongKmer::<2>::from_ascii(b"GGGGAC").unwrap();
+        let y = LongKmer::<2>::from_ascii(b"GGGGACAA").unwrap();
+
+        assert!(x < y);
+
+        let x = LongKmer::<2>::from_ascii(b"AATCAGCTAGCTACTATCTACGTACTACGTACGGGCGTACGTAGCAA").unwrap();
+        let y = LongKmer::<2>::from_ascii(b"AATCAGCTAGCTACTATCTACGTACTACGTACGGGCGTACGTAGCA").unwrap();
+
+        assert!(x > y);
+        */
+    }
+}
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
index 0fbbd76..a9b5100 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -125,9 +125,16 @@
 // String algorithms are often clearer with explicit indexing
 #![allow(clippy::needless_range_loop)]
 
+// Construction algorithms
 mod bitpacked_kmer_sorting;
+
+#[cfg(feature = "bpks-mem")]
+mod bitpacked_kmer_sorting_mem;
+
+
 mod tempfile;
 mod util;
+mod kmer;
 
 pub mod dbg;
 pub mod benchmark;
diff --git a/src/sbwt.rs b/src/sbwt.rs
index 2401424..46bafe2 100644
--- a/src/sbwt.rs
+++ b/src/sbwt.rs
@@ -571,6 +571,9 @@ mod tests {
 
     use crate::builder::{BitPackedKmerSorting, SbwtIndexBuilder};
 
+    #[cfg(feature = "bpks-mem")]
+    use crate::builder::BitPackedKmerSortingMem;
+
     use super::*;
 
     #[allow(non_snake_case)]
@@ -707,4 +710,132 @@ mod tests {
         assert_eq!(kmers1, kmers2);
 
     }
+
+    ///////////////////////////////////////////////////
+    //
+    // Same tests for bitpacked k-mer sorting in memory
+    //
+    ///////////////////////////////////////////////////
+
+    #[test_log::test]
+    #[allow(non_snake_case)]
+    #[cfg(feature = "bpks-mem")]
+    fn doc_example_mem() {
+        // The example used in the documentation page for SbwtIndex.
+        let seqs: Vec<&[u8]> = vec![b"TGTTTG", b"TTGCTAT", b"ACGTAGTATAT", b"TGTAAA"];
+        let (sbwt, _) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).run_from_slices(seqs.as_slice());
+        let mut doc_sbwt = vec![vec![b'A',b'T'], vec![b'C'], vec![], vec![b'A'], vec![b'T'], vec![b'T'], vec![b'A',b'G',b'T'], vec![], vec![], vec![b'G'], vec![b'T'], vec![b'T'], vec![b'T'], vec![b'T'], vec![b'C'], vec![b'G'], vec![b'A'], vec![], vec![], vec![b'A'], vec![b'A'], vec![b'A'], vec![b'A',b'T'], vec![b'T'], vec![b'G']];
+
+        // ACGT to 0123
+        for set in doc_sbwt.iter_mut() {
+            for c in set.iter_mut(){
+                *c = sbwt.char_idx(*c) as u8;
+            }
+        }
+        let computed_sbwt: Vec<Vec<u8>> = (0..sbwt.n_sets()).map(|i| sbwt.sbwt.access(i)).collect();
+        assert_eq!(doc_sbwt, computed_sbwt);
+    }
+
+    #[test_log::test]
+    #[allow(non_snake_case)]
+    #[cfg(feature = "bpks-mem")]
+    fn LCS_paper_example_mem() {
+
+        let seqs: Vec<&[u8]> = vec![b"AGGTAAA", b"ACAGGTAGGAAAGGAAAGT"];
+
+        let (mut sbwt, _) = SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).run_from_slices(seqs.as_slice());
+
+        assert_eq!(sbwt.sbwt.len(), 18);
+
+        assert_eq!(sbwt.sbwt.access(0), encode("A")); //   $$$$
+        assert_eq!(sbwt.sbwt.access(1), encode("C")); //   $$$A
+        assert_eq!(sbwt.sbwt.access(2), encode("G")); //   GAAA
+        assert_eq!(sbwt.sbwt.access(3), encode("")); //    TAAA
+        assert_eq!(sbwt.sbwt.access(4), encode("A")); //   GGAA
+        assert_eq!(sbwt.sbwt.access(5), encode("A")); //   GTAA
+        assert_eq!(sbwt.sbwt.access(6), encode("G")); //   $ACA
+        assert_eq!(sbwt.sbwt.access(7), encode("A")); //   AGGA
+        assert_eq!(sbwt.sbwt.access(8), encode("AG")); //  GGTA
+        assert_eq!(sbwt.sbwt.access(9), encode("A")); //   $$AC
+        assert_eq!(sbwt.sbwt.access(10), encode("GT")); // AAAG
+        assert_eq!(sbwt.sbwt.access(11), encode("G")); //  ACAG
+        assert_eq!(sbwt.sbwt.access(12), encode("G")); //  GTAG
+        assert_eq!(sbwt.sbwt.access(13), encode("AT")); // AAGG
+        assert_eq!(sbwt.sbwt.access(14), encode("")); //   CAGG
+        assert_eq!(sbwt.sbwt.access(15), encode("")); //   TAGG
+        assert_eq!(sbwt.sbwt.access(16), encode("")); //   AAGT
+        assert_eq!(sbwt.sbwt.access(17), encode("A")); //  AGGT
+
+        let true_padded_spectrum: Vec<&[u8]> = vec![b"$$$$", b"$$$A", b"GAAA", b"TAAA", b"GGAA", b"GTAA", b"$ACA", b"AGGA", b"GGTA", b"$$AC", b"AAAG", b"ACAG", b"GTAG", b"AAGG", b"CAGG", b"TAGG", b"AAGT", b"AGGT"];
+
+        let reconstructed_padded_spectrum = sbwt.reconstruct_padded_spectrum();
+        sbwt.sbwt.build_select();
+        #[allow(clippy::needless_range_loop)]
+        for i in 0..18 {
+            eprintln!("{} {}",i, String::from_utf8_lossy(&sbwt.access_kmer(i)));
+            assert_eq!(sbwt.access_kmer(i), true_padded_spectrum[i]);
+            assert_eq!(&reconstructed_padded_spectrum[i*sbwt.k..(i+1)*sbwt.k], true_padded_spectrum[i]);
+        }
+
+
+        assert_eq!(sbwt.search(b""), Some(0..18));
+        assert_eq!(sbwt.search(b"AGG"), Some(13..16));
+        assert_eq!(sbwt.search(b"AAGT"), Some(16..17));
+
+        // Test prefix looup table
+        let two_mers = [b"AA", b"AC", b"AG", b"AT", b"CA", b"CC", b"CG", b"CT", b"GA", b"GC", b"GG", b"GT", b"TA", b"TC", b"TG", b"TT"];
+        let lut = PrefixLookupTable::new(&sbwt, 2);
+        for two_mer in two_mers {
+            let I1 = match sbwt.search(two_mer){
+                Some(I) => I,
+                None => 0..0
+            };
+            let I2 = lut.lookup(two_mer);
+            assert_eq!(I1, I2);
+        }
+    }
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn serialize_and_load_mem() {
+        let seqs: Vec<&[u8]> = vec![b"AGGTAAA", b"ACAGGTAGGAAAGGAAAGT"];
+
+        let (sbwt, _) = crate::builder::SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).run_from_slices(seqs.as_slice());
+
+        let mut buf = Vec::<u8>::new();
+        sbwt.serialize(&mut buf).unwrap();
+        let sbwt2 = SbwtIndex::<SubsetMatrix>::load(&mut buf.as_slice()).unwrap();
+
+        assert_eq!(sbwt, sbwt2);
+    }
+
+    #[test]
+    #[allow(non_snake_case)]
+    #[cfg(feature = "bpks-mem")]
+    fn non_ACGT_mem(){
+        let seqs: Vec<&[u8]> = vec![b"AGGTAAA", b"ACAGGTAGGANAAGGAAAGT"];
+        //..................................................^...................
+
+        let (sbwt, _) = crate::builder::SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).run_from_slices(seqs.as_slice());
+
+        let mut buf = Vec::<u8>::new();
+        sbwt.serialize(&mut buf).unwrap();
+        let sbwt2 = SbwtIndex::<SubsetMatrix>::load(&mut buf.as_slice()).unwrap();
+
+        assert_eq!(sbwt, sbwt2);
+    }
+
+    #[test]
+    #[cfg(feature = "bpks-mem")]
+    fn from_subset_seq_mem() {
+        let seqs: Vec<&[u8]> = vec![b"AGGTAAA", b"ACAGGTAGGAAAGGAAAGT"];
+        let (sbwt_index, _) = crate::builder::SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).run_from_slices(seqs.as_slice());
+        let ss = sbwt_index.sbwt().clone();
+        let sbwt_index2 = SbwtIndex::<SubsetMatrix>::from_subset_seq(ss, sbwt_index.n_sets(), sbwt_index.k(), sbwt_index.prefix_lookup_table.prefix_length);
+
+        let kmers1 = sbwt_index.reconstruct_padded_spectrum();
+        let kmers2 = sbwt_index2.reconstruct_padded_spectrum();
+        assert_eq!(kmers1, kmers2);
+
+    }
 }
diff --git a/src/streaming_index.rs b/src/streaming_index.rs
index a32815b..2df0b31 100644
--- a/src/streaming_index.rs
+++ b/src/streaming_index.rs
@@ -256,6 +256,9 @@ mod tests {
 
     use crate::builder::BitPackedKmerSorting;
 
+    #[cfg(feature = "bpks-mem")]
+    use crate::builder::BitPackedKmerSortingMem;
+
     use super::*;
 
     #[test_log::test]
@@ -353,5 +356,108 @@ mod tests {
         eprintln!("{:?}", SFS);
     }
 
+    ///////////////////////////////////////////////////
+    //
+    // Same tests for bitpacked k-mer sorting in memory
+    //
+    ///////////////////////////////////////////////////
+
+
+    #[test_log::test]
+    #[allow(non_snake_case)]
+    #[cfg(feature = "bpks-mem")]
+    fn LCS_paper_example_mem() {
+        let seqs: Vec<&[u8]> = vec![b"AGGTAAA", b"ACAGGTAGGAAAGGAAAGT"];
+
+        let (sbwt, lcs) = crate::builder::SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(4).build_lcs(true).run_from_slices(seqs.as_slice());
+        let lcs = lcs.unwrap();
+        let from_sbwt = LcsArray::from_sbwt(&sbwt);
+
+        let true_lcs = [0,0,1,3,2,2,1,1,1,0,0,2,2,1,3,3,0,2];
+        for i in 0..lcs.len() {
+            println!("LCS {}", lcs.access(i));
+            assert_eq!(true_lcs[i], lcs.access(i));
+            assert_eq!(true_lcs[i], from_sbwt.access(i));
+        }
+
+        // Test streaming support
+        let SS = StreamingIndex::<SbwtIndex::<SubsetMatrix>, LcsArray>{contract_left: &lcs, extend_right: &sbwt, n: sbwt.n_sets(), k: sbwt.k()};
+        let mut I = 0..sbwt.sbwt.len();
+        I = SS.extend_right.extend_right(I, b'A') ;
+        I = SS.extend_right.extend_right(I, b'G') ;
+        I = SS.extend_right.extend_right(I, b'G') ;
+        assert_eq!(I, 13..16);
+
+        let I3 = SS.contract_left.contract_left(I.clone(), 3);
+        assert_eq!(I3, 13..16);
+
+        let I2 = SS.contract_left.contract_left(I.clone(), 2);
+        assert_eq!(I2, 13..16);
+
+        let I1 = SS.contract_left.contract_left(I.clone(), 1);
+        assert_eq!(I1, 10..16);
+
+        let I0 = SS.contract_left.contract_left(I.clone(), 0);
+        assert_eq!(I0, 0..18);
+        dbg!(I3, I2, I1, I0);
+
+    }
+
+    #[test]
+    #[allow(non_snake_case)]
+    #[cfg(feature = "bpks-mem")]
+    fn finimizer_paper_example_mem(){
+
+        // This is a pretty weak test but it's something.
+        // Using the example from the finimizer paper.
+        let seqs: Vec<&[u8]> = vec![b"GTAAGTCT", b"AGGAAA", b"ACAGG", b"GTAGG", b"AGGTA"];
+        let k = 4;
+
+        let (sbwt, lcs) = crate::builder::SbwtIndexBuilder::<BitPackedKmerSortingMem>::new().k(k).build_lcs(true).run_from_slices(seqs.as_slice());
+        let lcs = lcs.unwrap();
+        let SS = StreamingIndex::new(&sbwt, &lcs);
+        let MS = SS.matching_statistics(b"AAGTAA");
+        eprintln!("{:?}", MS);
+        let true_MS_lengths: [usize; 6] = [1,2,3,4,3,4];
+        let true_MS_freqs: [usize; 6] = [7,3,1,1,1,1];
+        let true_MS_colex_starts: [usize; 6] = [2,3,11,17,8,5];
+        assert_eq!(MS.len(), true_MS_lengths.len());
+        for i in 0..MS.len(){
+            assert_eq!(MS[i].0, true_MS_lengths[i]);
+            assert_eq!(MS[i].1.len(), true_MS_freqs[i]);
+            assert_eq!(MS[i].1.start + 1, true_MS_colex_starts[i]); // Paper has 1-indexing
+        }
+
+        let mut SFS = SS.shortest_freq_bound_suffixes(b"AAGTAA", 1);
+
+        let true_SFS = [None, None, Some((3,11..12)), Some((3, 17..18)), Some((2, 8..9)), Some((3, 5..6))];
+
+        // Put our SFS in 1-based indexing
+        for item in SFS.iter_mut(){
+            if let Some(X) = item{
+                *item = Some((X.0, X.1.start + 1..X.1.end + 1));
+            }
 
-}
\ No newline at end of file
+        }
+        eprintln!("{:?}", SFS);
+
+        assert_eq!(SFS, true_SFS);
+
+        // Let's try a query that has an invalid character
+        let mut SFS = SS.shortest_freq_bound_suffixes(b"AANAAGTAA", 1);
+
+        let true_SFS = [None, None, None, None, None, Some((3,11..12)), Some((3, 17..18)), Some((2, 8..9)), Some((3, 5..6))];
+
+        // Put our SFS in 1-based indexing
+        for item in SFS.iter_mut(){
+            if let Some(X) = item{
+                *item = Some((X.0, X.1.start + 1..X.1.end + 1));
+            }
+
+        }
+        assert_eq!(SFS, true_SFS);
+
+        eprintln!("{:?}", SFS);
+    }
+
+}
diff --git a/src/util.rs b/src/util.rs
index 9f69743..f398081 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -1,7 +1,11 @@
 //! Miscellaneous utility functions and constants used in the crate.
 
 use bitvec::prelude::*;
-use simple_sds_sbwt::raw_vector::AccessRaw;
+use simple_sds_sbwt::bit_vector::BitVector;
+use simple_sds_sbwt::ops::Select;
+use rayon::iter::IntoParallelRefIterator;
+use rayon::iter::IndexedParallelIterator;
+use rayon::iter::ParallelIterator;
 
 // Returns the number of bytes written
 pub(crate) fn write_bytes<W: std::io::Write>(out: &mut W, bytes: &[u8]) -> std::io::Result<usize>{
@@ -40,18 +44,17 @@ pub const ACGT_TO_0123: [u8; 256] = [255, 255, 255, 255, 255, 255, 255, 255, 255
 pub(crate) fn get_C_array(rawrows: &[simple_sds_sbwt::raw_vector::RawVector]) -> Vec<usize> {
     let sigma = rawrows.len();
     assert!(sigma > 0);
-    let n = rawrows[0].len();
-
-    let mut C: Vec<usize> = vec![0; sigma];
-    for i in 0..n {
-        for c in 0..(sigma as u8) {
-            if rawrows[c as usize].bit(i){
-                for d in (c + 1)..(sigma as u8) {
-                    C[d as usize] += 1;
-                }
+
+    let mut C: Vec<usize> = rawrows.par_iter().enumerate().map(|(c, rawrow)| {
+        let bv = BitVector::from(rawrow.clone());
+        let mut C: Vec<usize> = vec![0; sigma];
+        bv.one_iter().for_each(|_| {
+            for d in (c + 1)..(sigma) {
+                C[d as usize] += 1;
             }
-        }
-    }
+        });
+        C
+    }).reduce(|| vec![0; sigma], |a, b| a.iter().zip(b.iter()).map(|(x, y)| x + y).collect());
 
     // Plus one for the ghost dollar
     #[allow(clippy::needless_range_loop)] // Is perfectly clear this way
@@ -67,6 +70,7 @@ pub fn reverse_complement_in_place(seq: &mut [u8]){
     jseqio::reverse_complement_in_place(seq);
 }
 
+#[allow(dead_code)]
 pub(crate) struct FastXReader{
     inner: jseqio::reader::DynamicFastXReader
 }
@@ -125,4 +129,4 @@ impl<'a> crate::SeqStream for VecSeqStream<'a> {
             Some(s)
         }
     } 
-}
\ No newline at end of file
+}
